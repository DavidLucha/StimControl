function [p,g] = readProtocol(filename,varargin)

% NB THINGS TO VALIDATE:
% hardware is not targeted by two functions simultaneously
% oddball params are valid: 
    % with buffers, it's physically possible to leave a buffer of x stims at nstims y and swap ratio z

%% parse inputs
ip = inputParser;
addRequired(ip,'filename',...
    @(x)validateattributes(x,{'char'},{'nonempty'}));
parse(ip,filename,varargin{:});

%% read file
if ~exist(ip.Results.filename,'file')
    error('File not found: %s',ip.Results.filename)
end
pathBase = ip.Results.filename(1:find(ip.Results.filename == filesep, 1,'last'));
fid   = fopen(ip.Results.filename);
lines = textscan(fid,'%s','Delimiter','\n','MultipleDelimsAsOne',1);
fclose(fid);
lines = lines{1};

%% remove comment lines
lines(cellfun(@(x) strcmp(x(1),'%'),lines)) = [];

%% define defaults
g = struct(...              % general parameters
    'dPause',               5,...
    'nProtRuns',            1,...
    'rand',                 0);
trial = struct( ...
    'nRuns',                1, ...
    'tPre',                 1000, ...
    'tPost',                5000);
stimBlock = struct( ...
    'nStims',               1, ...
    'repDel',               0, ...
    'startDel',             0);

% function st1 = mergeStructs(st1, st2)
%     fs = fields(st2);
%     for i = 1:length(fs)
%         if ~isfield(st1, fs{i})
%             st1.(fs{i}) = st2.(fs{i});
%         end
%     end
% end

% standardStimStruct = struct( ...
%     'type', '', ...
%     'identifier', '', ...
%     'targetDevices', [], ...
%     'isAcquisitionTrigger', false, ...
%     'duration', 0);
BaseStimStructs = struct(...
    'qst', struct( ...
        'identifier', 'QST', ....
        'type', 'serial', ...
        'targetDevices', ["QST"], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'commands', struct(...
            'NeutralTemp',          32,...    
            'PacingRate',           ones(1,5) * 999,...
            'ReturnSpeed',          ones(1,5) * 999,...
            'SetpointTemp',         ones(1,5) * 32,...
            'SurfaceSelect',        true(1,5),...
            'dStimulus',            ones(1,5) * 1000,...
            'integralTerm',         1,...
            'nTrigger',             255,...
            'VibrationDuration',    0)), ...
    'serial', struct( ...
        'identifier', '', ....
        'type', 'serial', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'commands', []), ...
    'pwm', struct( ...
        'type', 'PWM', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'rampUp', 0, ...
        'rampDown', 0, ...
        'frequency', 25, ...
        'dutyCycle', 50), ...
    'piezo', struct( ...
        'identifier', 'piezoStim', ....
        'type', 'piezo', ...
        'targetDevices', ["Aurora"], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'frequency', 0, ...
        'stimNum', 0, ...
        'amplitude', 0, ...
        'ramp', 20, ...
        'nStims', 0), ...
    'digitaltrigger', struct( ...
        'type', 'digitalTrigger', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'frequency', 20), ...
    'digitalpulse', struct( ...
        'type', 'digitalPulse', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0), ...
    'analogpulse', struct( ...
        'type', 'analogPulse', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'rampOn', 0, ...
        'rampOff', 0, ...
        'baseAmp', 0, ...
        'pulseAmp', 10), ...
    'sinewave', struct( ...
        'type', 'sineWave', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'amplitude', 0, ...
        'frequency', 30, ...
        'phase', 0, ...
        'verticalShift', 0, ...
        'amplitudeMod', 1), ...
    'analognoise', struct( ...
        'type', 'analogNoise', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'maxAmplitude', 10, ...
        'minAmplitude', -10, ...
        'distribution', 'normal'), ... %either normal or uniform
    'arbitrary', struct( ...
        'type', 'arbitrary', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'filename', '', ...
        'interpolate', false), ...
    'squarewave', struct( ...
        'type', 'squareWave', ...
        'identifier', '', ...
        'targetDevices', [], ...
        'isAcquisitionTrigger', false, ...
        'duration', 0, ...
        'frequency', 20, ...
        'pulseWidth', 0.5, ...
        'maxAmp', 10, ...
        'minAmp', -10));

validProtocolParams = struct(... %fields: valid params in protocol file. values: associated internal struct params.
    'pwm', struct( ...
        'Dur', 'duration', ...
        'Freq', 'frequency', ...
        'DC', 'dutyCycle', ...
        'RampOnDur', 'rampUp', ...
        'RampOffDur', 'rampDown'), ...
    'piezo', struct(...
        'Dur', 'duration', ...
        'Freq', 'frequency', ...
        'stimNum', 'stimNum', ...
        'Amp', 'amplitude', ...
        'Ramp', 'ramp', ...
        'nStims', 'nStims'), ...
    'digitaltrigger', struct(  ...
        'Dur', 'duration', ...
        'Freq', 'frequency'), ...
    'digitalpulse', struct( ...
        'Dur', 'duration'), ...
    'analogpulse', struct(...
        'Dur', 'duration', ...
        'RampOnDur', 'rampOn', ...
        'RampOffDur', 'rampOff', ...
        'Amp', 'pulseAmp', ...
        'BaseAmp', 'baseAmp'), ...
    'sinewave', struct(...
        'Dur', 'duration', ...
        'Amp', 'amplitude', ...
        'Freq', 'frequency', ...
        'Phase', 'phase', ...
        'VShift', 'verticalShift', ...
        'AmpMod', 'amplitudeMod'), ... %nb special case? todo, low prio, just don't implement for now
    'analognoise', struct( ...
        'Dur', 'duration', ...
        'Max', 'maxAmplitude', ...
        'Min', 'minAmplitude', ...
        'Distr', 'distribution'), ... 
    'arbitrary', struct( ...
        'Dur', 'duration', ...
        'Src', 'filename', ... %nb special case
        'Interp', 'interpolate'), ...
    'squarewave', struct( ...
        'Dur', 'duration', ...
        'Max', 'maxAmp', ...
        'Min', 'minAmp', ...
        'Freq', 'frequency', ...
        'PW', 'pulseWidth'));

oddballParams = struct(...
    'distributionMethod', 'random', ... %even / random / semirandom
    'minSwapDist', 0, ...
    'swapRatio', 0.5, ...
    'oddballRel', 'rand'); % rand / seq - | or |> 

% %% Finish initialising.
% p = repmat(p,1,1000);

splitIdxes = find(startsWith(lines, '~'));
if length(splitIdxes) ~= 2
    error("Sections should be separated with a tilde (~) character on a new line. " + ...
        "Refer to the wiki for a full overview of formatting requirements: " + ...
        "https://github.com/WhitmireLab/StimControl/wiki/Protocols");
end

trialParams = lines(splitIdxes(1)+1:splitIdxes(2)-1);
stimDefinitions = lines(splitIdxes(2)+1:end);

%% Parse general specs
if splitIdxes(1) > 1
    if splitIdxes(1) > 2
        error("General params should be defined in a single line.");
    end
    generalParams = lines{1:splitIdxes(1)-1};
    [generalParams,~]  = strtok(generalParams,'%');
    generalParams      = strtrim(generalParams);
    while ~isempty(generalParams)
        [token,generalParams] = strtok(generalParams); %#ok<STTOK>
        tmp = regexpi(token,'^([a-z]+)(-?\d+)$','once','tokens');
        if ~isempty(tmp)
            val = str2double(tmp(2));
            switch lower(tmp{1})
                case 'nprotruns'
                    validateattributes(val,{'numeric'},{'positive'},...
                        mfilename,token)
                    g.nProtRuns = val;
                    continue
                case 'rand'
                    validateattributes(val,{'numeric'},{'nonnegative',...
                        '<=',2},mfilename,token)
                    g.rand = val;
                    continue
                case 'dpause'
                    validateattributes(val,{'numeric'},{'nonnegative'},...
                        mfilename,token)
                    g.dPause = val;
                    continue
                case 'ntrialruns'
                    validateattributes(val,{'numeric'},{'nonnegative'},...
                        mfilename,token)
                    trial.nRuns = val;
                    continue
                case 'tpre'
                    validateattributes(val,{'numeric'},{'nonnegative'},...
                        mfilename,token)
                    trial.tPre = val;
                    continue
                case 'tpost'
                    validateattributes(val,{'numeric'},{'nonnegative'},...
                        mfilename,token)
                    trial.tPost = val;
                continue
            end
        end
        error('Unknown parameter "%s"',token)
    end
end

stimuli = [];

%% parse stimulus definitions
for idxStim = 1:length(stimDefinitions)
    line = stimDefinitions{idxStim};
    tmp = regexpi(line, '([A-z])*\((\w)+\)\[((\w)(-\w)?,? ?)+\]: ?(.*)(%.*)?', 'tokens', 'once'); %todo support for only targeting Widefield1-Trigger, for e.g.
    [stimID, stimType, targets, params, comment] = tmp{:};
    stimType = lower(stimType);
    if isfield(stimuli, stimID)
        error("Stimulus defined twice: %s", stimID);
    end
    if ~contains(fields(BaseStimStructs), stimType)
        error("Unknown stimulus type: %s. Valid types: %s", stimType, GetListFromArray(fields(BaseStimStructs)));
    end
    % special cases
    switch lower(stimType)
        case 'qst'
            stimStruct = ParseQST(params, BaseStimStructs.(stimType), stimID);
        case 'serial'
            stimStruct = ParseSerial(params, BaseStimStructs.(stimType), stimID);
        otherwise
            % standard cases
            stimStruct = BaseStimStructs.(stimType);
            while ~isempty(params)
                [tok, remain] = strtok(params);
                pv = regexpi(tok, '([A-z]*)(-?\d*.?\d*)', 'tokens', 'once');
                [param, val] = pv{:};
                if strcmpi(param, 'acquisitiontrigger')
                    stimStruct.isAcquisitionTrigger = true;
                    params = remain;
                    continue
                elseif isempty(val) || isnan(str2double(val))
                    if strcmpi(stimType, 'arbitrary')
                        % probably the filename
                        param = 'Src';
                        val = tok;
                        if ~contains(val, filesep)
                            % expand to full filepath
                            val = [pathBase val];
                        end
                    else
                        error("No value provided for %s:%s", stimID, stimType);
                    end
                elseif ~contains(fields(validProtocolParams.(stimType)), param)
                    error("Invalid parameter for %s: %s. Valid parameters are: %s", ...
                        stimID, param, GetListFromArray(fields(validProtocolParams.(stimType))));
                end
                val = ValidateParam(val, param, stimID);
                stimStruct.(validProtocolParams.(stimType).(param)) = val;
                params = strtrim(remain);
            end
    end
    stimuli.(stimID) = stimStruct;
    stimuli.(stimID).targets = string(targets); % todo convert to array of strings if length > 1
end

%% Parse trials
for idxTrial = 1:length(trialParams)
    % s = {StimulusBlock('childIdxes', [2 3]), ... 
    %         StimulusBlock('stimParams', cameraTriggerStruct), ...
    %         StimulusBlock('childIdxes', [4 5 6], 'startDelay', td.tPre), ...
    %         StimulusBlock('stimParams', qs), ...
    %         StimulusBlock('stimParams', ls), ...
    %         StimulusBlock('stimParams', ps)};
    trialNodes = {};
    trialNodeIdxes = [];
    trialNodeChildren = [];
    line = trialParams{idxTrial};
    [params, comment] = strtok(line, '%');
    params = strtrim(params);
    comment = strtrim(comment);
    closeIdxes = strfind(params, ')');
    openIdxes = strfind(params, '(');
    if length(openIdxes) ~= length(closeIdxes)
        error("Unmatched bracket on trial line %d (%s)", idxTrial, comment);
    end
    nBracketPairs = length(closeIdxes);
    if nBracketPairs ~= 0
        for i = 1:nBracketPairs
            closeIdx = closeIdxes(1);
            tmp = linspace(1, length(openIdxes), length(openIdxes));
            openIdx = max(tmp(openIdxes < closeIdx));
            substring = params(openIdx+1:closeIdx-1);
            trialNodes{end} = ConstructStimSubtree(substring, trialNodes, trialNodeIdxes, trialNodeChildren, idxTrial, comment); %todo might be a series of nodes!!
            trialNodeNames.(['trialNode_' char(48+i)]) = length(trialNodes);
            params = [params(1:openIdx) 'trialNode_' char(48+i) params(closeIdx:end)];
        end
    end
    find(params, ')');
end

function [Nodes, Idxes, Children] = ConstructStimSubtree(params, Nodes, Idxes, Children, idxTrial, Comment)
    sepQuery = ' ?(&|>|(\|>)|(\^\.\d?))? ?';
    if ~regexpi(params, sepQuery)
        error("Syntax error in trial line %d (%s): Individual stimuli should not be placed in brackets.", idxTrial, Comment);
    end
    params = strtrim(params);
    separators = regexpi(params, sepQuery, 'tokens');
    separators = [separators{:}];
    if any(cellfun(@(c) ~strcmpi(c, separators{1}), separators))
        error("Syntax error in trial line %d (%s): Only one relationship type may exist per stim block", idxTrial, Comment);
    end
    rln = separators{1};
    tokens = regexpi(params, ['(\w*\d*)' sepQuery '(\w*\d*))*'], 'tokens', 'once');
    for idxTok = 1:length(tokens)
        subtok = regexpi(tokens(idxTok), ['(' sepQuery ')?' '(\w*)(\d+)?'], 'tokens', 'once');
        subtok = subtok{:};
        [~, tknName, value] = subtok{:};
        switch tknName
            case 'tPre'

            case 'tPost'

            case 'startDel'

            case 'repDel'

            case 'nTrialRuns'

            case 'nStims'

            case 'oddDistr'

            case 'minSwapDist'

            otherwise
                if ~isfield(stimuli, tkName)
                    error("Invalid parameter on trial definition line %d: %s. " + ...
                        "Parameters must be a stimulis defined in the stimulus section " + ...
                        "or one of the following: %s", idxTrial, tkName, ...
                        GetListFromArray({"tPre", "tPost", "nTrialRuns", "oddDistr", "minSwapDist", "repDel", "nStims", "startDel"}));
                end
                % set child node data
        end
    end
end

function stimStruct = ParseArbitrary(params, stimStruct, stimName)
    tmp = regexpi(tok, '^([A-Z]*)(\:)(.*)$', 'once', 'tokens');
    id = tmp{1};
    filename = tmp{3};
    % extend filename if necessary
    if ~contains(filename, ':')
        % referenced in relation to location of protocol file
        % standardise fileseps
        filename = replace(filename,'/',filesep);
        filename = replace(filename,'\',filesep);
        % extend to full path
        filename = [pathBase filename];
    end
    % read file
    if ~exist(filename,'file')
        error('File not found: %s',filename)
    end
    fid   = fopen(filename);
    lines = textscan(fid,'%s','Delimiter','\n','MultipleDelimsAsOne',1);
    fclose(fid);
    lines = lines{1};
    
    % remove comment lines
    lines(cellfun(@(x) (strcmp(x(1),'%') || strcmp(x(2), '%')) ,lines)) = [];
    try
        type = lower(lines{1});
        protocol = str2num(lines{2});
    catch
        error("Invalid protocol in file %s. Protocol line should have only numbers", filename);
    end
    if ~contains(['digital', 'analog'], type)
        error("invalid data type %s in file %s", type, filename);
    end
    p(idxStim).(id).type = type;
    p(idxStim).(id).filename = filename;
    p(idxStim).(id).data = protocol;
end

function stimStruct = ParseQST(params, stimStruct, stimName)
    while ~isempty(params)
        [tok, remain] = strtok(params);
        switch tok(1)
            case 'N'
                fieldname = 'NeutralTemp';
                value     = readRangeThermode(tok,2:4,[200 500],stimName)/10;
            case 'S'
                fieldname = 'SurfaceSelect';
                value     = tok(2:6)=='1';
            case 'C'
                fieldname = 'SetpointTemp';
                value     = readRangeThermode(tok,3:5,[0 600],stimName)/10;
            case 'V'
                fieldname = 'PacingRate';
                value     = readRangeThermode(tok,3:6,[1 9990],stimName)/10;
            case 'R'
                fieldname = 'ReturnSpeed';
                value     = readRangeThermode(tok,3:6,[100 9990],stimName)/10;
            case 'D'
                fieldname = 'dStimulus';
                value     = readRangeThermode(tok,3:7,[10 99999],stimName);
            case 'T'
                fieldname = 'nTrigger';
                value     = readRangeThermode(tok,2:4,[0 255],stimName);
            case 'I'
                fieldname = 'integralTerm';
                value     = tok(2)=='1';
        end
        stimStruct.commands.(fieldname) = value;
        params = remain;
    end
end

function value = readRangeThermode(token,pos,range,stimName)
value = str2double(token(pos));
if value<range(1) || value>range(2)
    x = sprintf('%%0%dd',max(arrayfun(@(x) length(num2str(x)),range)));
    format = subsasgn(token,struct('type','()','subs',{{pos}}),'X');
    error(['Faulty parameter "%s" for stimulus #%d (%s, valid ' ...
        'range for %s: ' x '-' x ')'],token,stimName,format,...
        repmat('X',1,length(pos)),range(1),range(2))
end
end

function val = ValidateParam(val, paramName, stimName)
    if ~strcmpi(paramName, 'src')
        val = str2double(val);
    end
    switch lower(paramName)
    case 'dur'
        if ~val>0 && v~=-1
            error("Invalid duration for %s: %s. Duration should be a positive number of ms, or -1", stimName, val);
        end
    case 'freq'
        if ~val>0
            error("Invalid frequency for %s: %s. Frequency should be positive.", stimName, val);
        end
    case 'src'
        % check if filepath exists
        if ~isfile(val)
            error("Unable to find file %s for %s.", val, stimName);
        end
    case 'distr'
        if val == 1
            val = 'normal';
        elseif val == 0
            val = 'uniform';
        else
            error("Invalid distribution for %s: %s. Distribution can be 0 (uniform) or 1 (normal).", stimName, val);
        end
    end
end

function out = GetListFromArray(A)
    commas = repmat([", "], size(A));
    commas(end) = "";
    s = size(A);
    if s(1) == 1
        A = A';
        commas = commas';
    end
    arr = horzcat(A, commas);
    arr = append(arr(:,1), arr(:,2));
    out = strjoin(arr');
end
end



% function checkRange(value,range,token,idxStim)
% if value<range(1) || value>range(2)
%     error(['Faulty parameter "%s" for stimulus #%d (expecting value ' ...
%         'to be within %d-%d)'],token,idxStim,range(1),range(2))
% end
% end